# ZORA MODULE HEADER

"""
Module Name: zora_loader
Generated by ZORA SYSTEM ‚Äì All rights reserved.
Real-Time AI System Discovery and Dynamic Loading Engine for ZORA CORE
"""

import os
import sys
import json
import time
import glob
import logging
import threading
import importlib.util
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

class ZORADynamicLoader:
    """Real-time AI system discovery and dynamic loading engine"""
    
    def __init__(self):
        self.name = "ZORA_DYNAMIC_LOADER"
        self.user_name = "Mads Pallisgaard Petersen"
        self.email = "mrpallis@gmail.com"
        self.organization = "ZORA CORE"
        self.address = "Fjordbakken 50, Dyves Bro, 4700 N√¶stved"
        self.phone = "+45 22822450"
        
        self.base_path = os.path.dirname(__file__)
        self.modules_paths = [
            os.path.join(self.base_path, 'modules'),
            os.path.join(self.base_path, 'agents'),
            os.path.join(self.base_path, 'mcp_extensions'),
            self.base_path  # Root directory
        ]
        
        self.loaded_modules = {}
        self.failed_modules = {}
        self.watch_enabled = True
        self.auto_reload = True
        self.last_scan = None
        
        self.ai_patterns = [
            "*_agent.py",
            "*_ai.py", 
            "*ai*.py",
            "*gpt*.py",
            "*claude*.py",
            "*gemini*.py",
            "*openai*.py",
            "*anthropic*.py",
            "*meta*.py",
            "*copilot*.py",
            "*huggingface*.py",
            "*langchain*.py",
            "*mcp*.py",
            "module_*.py"
        ]
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def discover_ai_modules(self) -> List[Dict[str, Any]]:
        """Discover all AI modules in the system"""
        discovered = []
        
        for modules_path in self.modules_paths:
            if not os.path.exists(modules_path):
                continue
                
            for pattern in self.ai_patterns:
                pattern_path = os.path.join(modules_path, pattern)
                matches = glob.glob(pattern_path)
                
                for match in matches:
                    if os.path.isfile(match):
                        module_info = self.analyze_module(match)
                        if module_info:
                            discovered.append(module_info)
        
        return discovered
    
    def analyze_module(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Analyze a module file to extract AI system information"""
        try:
            filename = os.path.basename(file_path)
            module_name = filename[:-3] if filename.endswith('.py') else filename
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            module_info = {
                "name": module_name,
                "path": file_path,
                "size": os.path.getsize(file_path),
                "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat(),
                "discovered_at": datetime.utcnow().isoformat(),
                "type": self.classify_module_type(content, filename),
                "capabilities": self.extract_module_capabilities(content),
                "dependencies": self.extract_dependencies(content),
                "api_endpoints": self.extract_api_endpoints(content),
                "user_profile": {
                    "name": self.user_name,
                    "email": self.email,
                    "organization": self.organization,
                    "address": self.address,
                    "phone": self.phone
                }
            }
            
            return module_info
            
        except Exception as e:
            self.logger.error(f"Failed to analyze module {file_path}: {e}")
            return None
    
    def classify_module_type(self, content: str, filename: str) -> str:
        """Classify the type of AI module"""
        content_lower = content.lower()
        filename_lower = filename.lower()
        
        if any(indicator in filename_lower for indicator in ['agent', '_ai']):
            return "ai_agent"
        elif 'mcp' in filename_lower or 'extension' in filename_lower:
            return "mcp_extension"
        elif 'module_' in filename_lower:
            return "zora_module"
        elif any(api in content_lower for api in ['openai', 'anthropic', 'google', 'meta']):
            return "ai_api_client"
        elif 'langchain' in content_lower:
            return "langchain_tool"
        elif 'infinity' in content_lower or 'protocol' in content_lower:
            return "infinity_protocol"
        else:
            return "general_module"
    
    def extract_module_capabilities(self, content: str) -> List[str]:
        """Extract capabilities from module content"""
        capabilities = []
        content_lower = content.lower()
        
        capability_indicators = {
            "text_generation": ["generate", "completion", "text", "language"],
            "image_processing": ["image", "vision", "visual", "picture"],
            "audio_processing": ["audio", "speech", "voice", "sound"],
            "code_generation": ["code", "programming", "codex"],
            "chat": ["chat", "conversation", "assistant"],
            "embedding": ["embedding", "vector", "similarity"],
            "api_integration": ["api", "client", "request", "endpoint"],
            "monitoring": ["monitor", "health", "status", "watch"],
            "infinity_protocol": ["infinity", "protocol", "expansion"],
            "mcp_server": ["mcp", "server", "tool", "resource"]
        }
        
        for capability, keywords in capability_indicators.items():
            if any(keyword in content_lower for keyword in keywords):
                capabilities.append(capability)
        
        return capabilities if capabilities else ["general"]
    
    def extract_dependencies(self, content: str) -> List[str]:
        """Extract module dependencies"""
        dependencies = []
        
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if line.startswith('import ') or line.startswith('from '):
                if line.startswith('import '):
                    package = line.replace('import ', '').split('.')[0].split(' as ')[0]
                elif line.startswith('from '):
                    package = line.split(' ')[1].split('.')[0]
                
                if package and not package.startswith('.'):
                    dependencies.append(package)
        
        return list(set(dependencies))  # Remove duplicates
    
    def extract_api_endpoints(self, content: str) -> List[str]:
        """Extract API endpoints from module content"""
        endpoints = []
        
        import re
        url_pattern = r'https?://[^\s\'"<>]+'
        urls = re.findall(url_pattern, content)
        
        ai_domains = [
            'openai.com', 'anthropic.com', 'google.com', 'meta.com',
            'huggingface.co', 'replicate.com', 'stability.ai', 'cohere.ai'
        ]
        
        for url in urls:
            if any(domain in url for domain in ai_domains):
                endpoints.append(url)
        
        return list(set(endpoints))  # Remove duplicates
    
    def load_module_dynamically(self, module_info: Dict[str, Any]) -> bool:
        """Dynamically load a discovered AI module"""
        try:
            module_path = module_info["path"]
            module_name = module_info["name"]
            
            if module_name in self.loaded_modules:
                return True
            
            spec = importlib.util.spec_from_file_location(module_name, module_path)
            if spec is None:
                raise ImportError(f"Could not load spec for {module_name}")
            
            module = importlib.util.module_from_spec(spec)
            
            sys.modules[module_name] = module
            
            spec.loader.exec_module(module)
            
            self.loaded_modules[module_name] = {
                "module": module,
                "info": module_info,
                "loaded_at": datetime.utcnow().isoformat(),
                "status": "active"
            }
            
            self.logger.info(f"‚úÖ Dynamically loaded AI module: {module_name}")
            return True
            
        except Exception as e:
            self.failed_modules[module_info["name"]] = {
                "error": str(e),
                "failed_at": datetime.utcnow().isoformat(),
                "info": module_info
            }
            self.logger.error(f"‚ùå Failed to load module {module_info['name']}: {e}")
            return False
    
    def start_real_time_monitoring(self):
        """Start real-time monitoring for new AI modules"""
        if not self.watch_enabled:
            return False
        
        def monitoring_worker():
            while self.watch_enabled:
                try:
                    self.scan_and_load_new_modules()
                    time.sleep(30)  # Scan every 30 seconds
                except Exception as e:
                    self.logger.error(f"Monitoring error: {e}")
                    time.sleep(60)  # Wait 1 minute on error
        
        monitor_thread = threading.Thread(target=monitoring_worker, daemon=True)
        monitor_thread.start()
        
        self.logger.info("üîç Real-time AI module monitoring started")
        return True
    
    def scan_and_load_new_modules(self):
        """Scan for and load new AI modules"""
        self.last_scan = datetime.utcnow().isoformat()
        
        discovered_modules = self.discover_ai_modules()
        new_modules_count = 0
        
        for module_info in discovered_modules:
            module_name = module_info["name"]
            
            if module_name not in self.loaded_modules:
                if self.load_module_dynamically(module_info):
                    new_modules_count += 1
            elif self.auto_reload:
                current_modified = module_info["modified"]
                loaded_modified = self.loaded_modules[module_name]["info"]["modified"]
                
                if current_modified != loaded_modified:
                    if self.reload_module(module_info):
                        self.logger.info(f"üîÑ Reloaded updated module: {module_name}")
        
        if new_modules_count > 0:
            self.logger.info(f"üÜï Loaded {new_modules_count} new AI modules")
        
        return new_modules_count
    
    def reload_module(self, module_info: Dict[str, Any]) -> bool:
        """Reload an updated module"""
        module_name = module_info["name"]
        
        try:
            if module_name in sys.modules:
                del sys.modules[module_name]
            
            if module_name in self.loaded_modules:
                del self.loaded_modules[module_name]
            
            return self.load_module_dynamically(module_info)
            
        except Exception as e:
            self.logger.error(f"Failed to reload module {module_name}: {e}")
            return False
    
    def get_loader_status(self) -> Dict[str, Any]:
        """Get comprehensive loader status"""
        return {
            "name": self.name,
            "loaded_modules": len(self.loaded_modules),
            "failed_modules": len(self.failed_modules),
            "watch_enabled": self.watch_enabled,
            "auto_reload": self.auto_reload,
            "last_scan": self.last_scan,
            "modules_paths": self.modules_paths,
            "ai_patterns": len(self.ai_patterns),
            "user_profile": {
                "name": self.user_name,
                "email": self.email,
                "organization": self.organization,
                "address": self.address,
                "phone": self.phone
            }
        }
    
    def load_all_ai_modules(self):
        """Load all discovered AI modules"""
        discovered_modules = self.discover_ai_modules()
        
        self.logger.info(f"üîç Discovered {len(discovered_modules)} AI modules")
        
        success_count = 0
        for module_info in discovered_modules:
            if self.load_module_dynamically(module_info):
                success_count += 1
        
        self.logger.info(f"‚úÖ Successfully loaded {success_count}/{len(discovered_modules)} AI modules")
        return success_count

dynamic_loader = ZORADynamicLoader()

print("üåü ZORA DYNAMIC LOADER - INITIALIZING AI SYSTEM DISCOVERY...")
loaded_count = dynamic_loader.load_all_ai_modules()
print(f"‚úÖ Loaded {loaded_count} AI modules")

dynamic_loader.start_real_time_monitoring()
print("üîç Real-time AI module monitoring active")

modules_path = os.path.join(os.path.dirname(__file__), 'modules')
if os.path.exists(modules_path):
    for file in os.listdir(modules_path):
        if file.endswith('.py') and not file.startswith('__'):
            try:
                spec = importlib.util.spec_from_file_location(file[:-3], os.path.join(modules_path, file))
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
            except Exception as e:
                logging.error(f"Legacy module load failed for {file}: {e}")

print("üöÄ ZORA DYNAMIC LOADER - ALL SYSTEMS ACTIVE")
