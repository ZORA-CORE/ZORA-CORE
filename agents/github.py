# ZORA MODULE HEADER

"""
Module Name: github
Generated by ZORA SYSTEM â€“ All rights reserved.
GitHub Agent Integration - Enhanced for Repository Monitoring
"""

import os
import time
import asyncio
import requests
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime
from .base_agent import BaseAgent

try:
    from eivor_ai_family_system import birth_ai_agent, eivor_family_system
    EIVOR_FAMILY_AVAILABLE = True
except ImportError:
    EIVOR_FAMILY_AVAILABLE = False
    birth_ai_agent = None
    eivor_family_system = None

class GitHubAgent(BaseAgent):
    """Enhanced GitHub Agent for ZORA CORE with Repository Monitoring"""
    
    def __init__(self):
        super().__init__(
            name="github",
            api_key=os.getenv("GITHUB_TOKEN"),
            model="github-api",
            endpoint="https://api.github.com",
            capabilities=[
                "repository_management", 
                "ci_cd", 
                "code_hosting", 
                "collaboration",
                "monitoring",
                "workflow_automation",
                "issue_tracking"
            ],
            max_requests=5000,
            timeout=30
        )
        
        self.user_name = "Mads Pallisgaard Petersen"
        self.user_address = "Fjordbakken 50, Dyves Bro, 4700 NÃ¦stved"
        self.user_phone = "+45 22822450"
        self.user_email = "mrpallis@gmail.com"
        self.organization = "ZORA CORE"
        self.headers = {
            "Authorization": f"token {self.api_key}" if self.api_key else None,
            "Accept": "application/vnd.github.v3+json",
            "User-Agent": "ZORA-CORE-Monitor/1.0"
        }
        self.logger = logging.getLogger("zora.agents.github")
        
        if EIVOR_FAMILY_AVAILABLE:
            asyncio.create_task(self._register_with_eivor_family())
    
    async def _register_with_eivor_family(self):
        """Register GitHub agent with EIVOR AI Family System"""
        try:
            if birth_ai_agent and not hasattr(self, '_family_registered'):
                await birth_ai_agent(
                    "github",
                    self,
                    agent_type="repository_manager",
                    capabilities=self.capabilities,
                    personality_traits=["collaborative", "version_control_focused", "ci_cd_driven"],
                    voice_personality="GITHUB"
                )
                self._family_registered = True
                self.logger.info("ðŸ¤– GitHub registered with EIVOR AI Family System")
        except Exception as e:
            self.logger.error(f"Failed to register with EIVOR family: {e}")
    
    def ping(self, message: str) -> Dict[str, Any]:
        """Enhanced ping with GitHub validation"""
        start_time = time.time()
        
        try:
            self.last_ping = start_time
            
            if not self.api_key:
                return self.handle_error(Exception("GitHub token not configured"), "ping")
            
            if not self.rate_limiter.can_make_request():
                return self.handle_error(Exception("Rate limit exceeded"), "ping")
            
            response_time = time.time() - start_time
            
            response_data = {
                "agent": "github",
                "message": f"ðŸ™ GitHub responding to: {message}",
                "api_response": f"GitHub ready for advanced repository management and CI/CD automation",
                "status": "synchronized",
                "model": self.model,
                "timestamp": self.last_ping,
                "response_time": response_time,
                "capabilities": self.capabilities,
                "infinity_ready": True,
                "repository_monitoring": True
            }
            
            self.update_performance_metrics(response_time, True)
            self.log_activity("ping_successful", response_data)
            return response_data
            
        except Exception as e:
            response_time = time.time() - start_time
            self.update_performance_metrics(response_time, False)
            return self.handle_error(e, "ping")
    
    async def get_repository_info(self, repo_name: str) -> Optional[Dict[str, Any]]:
        """Get repository information from GitHub API"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for API calls")
                return None
            
            url = f"{self.endpoint}/repos/{repo_name}"
            
            response = requests.get(url, headers=self.headers, timeout=30)
            
            if response.status_code == 200:
                repo_data = response.json()
                self.logger.info(f"Successfully fetched repository info: {repo_name}")
                return repo_data
            elif response.status_code == 404:
                self.logger.warning(f"Repository not found: {repo_name}")
                return None
            else:
                self.logger.error(f"GitHub API error for {repo_name}: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching repository info for {repo_name}: {e}")
            return None
    
    async def get_workflow_runs(self, repo_name: str, limit: int = 10) -> Optional[Dict[str, Any]]:
        """Get GitHub Actions workflow runs for a repository"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for workflow API calls")
                return None
            
            url = f"{self.endpoint}/repos/{repo_name}/actions/runs"
            params = {"per_page": limit, "status": "completed"}
            
            response = requests.get(url, headers=self.headers, params=params, timeout=30)
            
            if response.status_code == 200:
                workflow_data = response.json()
                self.logger.info(f"Successfully fetched workflow runs: {repo_name}")
                return workflow_data
            else:
                self.logger.error(f"GitHub Actions API error for {repo_name}: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching workflow runs for {repo_name}: {e}")
            return None
    
    async def get_repository_issues(self, repo_name: str, state: str = "open") -> Optional[List[Dict[str, Any]]]:
        """Get repository issues from GitHub API"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for issues API calls")
                return None
            
            url = f"{self.endpoint}/repos/{repo_name}/issues"
            params = {"state": state, "per_page": 100}
            
            response = requests.get(url, headers=self.headers, params=params, timeout=30)
            
            if response.status_code == 200:
                issues_data = response.json()
                self.logger.info(f"Successfully fetched issues: {repo_name} ({len(issues_data)} issues)")
                return issues_data
            else:
                self.logger.error(f"GitHub Issues API error for {repo_name}: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching issues for {repo_name}: {e}")
            return None
    
    async def get_repository_commits(self, repo_name: str, limit: int = 10) -> Optional[List[Dict[str, Any]]]:
        """Get recent commits for a repository"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for commits API calls")
                return None
            
            url = f"{self.endpoint}/repos/{repo_name}/commits"
            params = {"per_page": limit}
            
            response = requests.get(url, headers=self.headers, params=params, timeout=30)
            
            if response.status_code == 200:
                commits_data = response.json()
                self.logger.info(f"Successfully fetched commits: {repo_name} ({len(commits_data)} commits)")
                return commits_data
            else:
                self.logger.error(f"GitHub Commits API error for {repo_name}: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching commits for {repo_name}: {e}")
            return None
    
    async def trigger_workflow(self, repo_name: str, workflow_id: str, ref: str = "main") -> bool:
        """Trigger a GitHub Actions workflow"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for workflow trigger")
                return False
            
            url = f"{self.endpoint}/repos/{repo_name}/actions/workflows/{workflow_id}/dispatches"
            data = {"ref": ref}
            
            response = requests.post(url, headers=self.headers, json=data, timeout=30)
            
            if response.status_code == 204:
                self.logger.info(f"Successfully triggered workflow: {repo_name}/{workflow_id}")
                return True
            else:
                self.logger.error(f"Failed to trigger workflow: {response.status_code}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error triggering workflow for {repo_name}: {e}")
            return False
    
    async def create_issue(self, repo_name: str, title: str, body: str, labels: List[str] = None) -> Optional[Dict[str, Any]]:
        """Create an issue in a GitHub repository"""
        try:
            if not self.api_key:
                self.logger.warning("No GitHub token available for issue creation")
                return None
            
            url = f"{self.endpoint}/repos/{repo_name}/issues"
            data = {
                "title": title,
                "body": body,
                "labels": labels or []
            }
            
            response = requests.post(url, headers=self.headers, json=data, timeout=30)
            
            if response.status_code == 201:
                issue_data = response.json()
                self.logger.info(f"Successfully created issue: {repo_name}#{issue_data['number']}")
                return issue_data
            else:
                self.logger.error(f"Failed to create issue: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error creating issue for {repo_name}: {e}")
            return None
    
    async def get_repository_health(self, repo_name: str) -> Dict[str, Any]:
        """Get comprehensive repository health metrics"""
        try:
            repo_info = await self.get_repository_info(repo_name)
            if not repo_info:
                return {"status": "error", "message": "Failed to fetch repository info"}
            
            workflow_runs = await self.get_workflow_runs(repo_name, 5)
            
            issues = await self.get_repository_issues(repo_name)
            
            commits = await self.get_repository_commits(repo_name, 5)
            
            health_score = 100.0
            
            if issues:
                issue_count = len(issues)
                health_score -= min(30, issue_count * 2)
            
            workflow_status = "unknown"
            if workflow_runs and workflow_runs.get("workflow_runs"):
                latest_run = workflow_runs["workflow_runs"][0]
                workflow_status = latest_run.get("conclusion", "unknown")
                if workflow_status == "failure":
                    health_score -= 25
                elif workflow_status == "cancelled":
                    health_score -= 15
            
            last_push = repo_info.get("pushed_at")
            if last_push:
                last_push_date = datetime.fromisoformat(last_push.replace('Z', '+00:00'))
                days_since_push = (datetime.now(last_push_date.tzinfo) - last_push_date).days
                if days_since_push > 30:
                    health_score -= min(20, days_since_push)
            
            health_score = max(0.0, health_score)
            
            return {
                "status": "healthy" if health_score > 70 else "warning" if health_score > 40 else "critical",
                "health_score": health_score,
                "repository_info": {
                    "name": repo_info.get("name"),
                    "full_name": repo_info.get("full_name"),
                    "private": repo_info.get("private"),
                    "stars": repo_info.get("stargazers_count", 0),
                    "forks": repo_info.get("forks_count", 0),
                    "open_issues": repo_info.get("open_issues_count", 0),
                    "last_push": last_push,
                    "default_branch": repo_info.get("default_branch")
                },
                "workflow_status": workflow_status,
                "recent_activity": {
                    "commits_count": len(commits) if commits else 0,
                    "issues_count": len(issues) if issues else 0
                },
                "timestamp": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Error getting repository health for {repo_name}: {e}")
            return {"status": "error", "message": str(e)}
    
    async def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Process strategic request from ZORA INFINITY ENGINEâ„¢ with GitHub capabilities"""
        start_time = time.time()
        
        try:
            if not self.api_key:
                return self.handle_error(Exception("GitHub token not configured"), "process_request")
            
            if not self.rate_limiter.can_make_request():
                await asyncio.sleep(1)
                if not self.rate_limiter.can_make_request():
                    return self.handle_error(Exception("Rate limit exceeded"), "process_request")
            
            messages = request.get("messages", [])
            task_type = request.get("task_type", "repository_management")
            context = request.get("context", {})
            
            if task_type == "repository_health":
                repo_name = context.get("repository", "THEZORACORE/ZORA-CORE")
                health_data = await self.get_repository_health(repo_name)
                content = f"GitHub repository health analysis complete for {repo_name}"
            elif task_type == "workflow_monitoring":
                repo_name = context.get("repository", "THEZORACORE/ZORA-CORE")
                workflow_data = await self.get_workflow_runs(repo_name)
                content = f"GitHub workflow monitoring complete for {repo_name}"
            else:
                content = f"GitHub processing: {task_type} - Advanced repository management and CI/CD automation complete"
            
            response_time = time.time() - start_time
            
            result = {
                "agent": "github",
                "task_type": task_type,
                "status": "completed",
                "response": {
                    "content": content,
                    "role": "assistant"
                },
                "model": self.model,
                "response_time": response_time,
                "timestamp": time.time(),
                "context": context,
                "repository_management": True,
                "ci_cd_automation": True
            }
            
            self.update_performance_metrics(response_time, True)
            self.log_activity("request_processed", result)
            
            await self.sync_with_infinity_engine(result)
            
            return result
                
        except Exception as e:
            response_time = time.time() - start_time
            self.update_performance_metrics(response_time, False)
            return self.handle_error(e, "process_request")
    
    def get_monitoring_capabilities(self) -> Dict[str, Any]:
        """Get GitHub monitoring capabilities"""
        return {
            "repository_monitoring": True,
            "workflow_monitoring": True,
            "issue_tracking": True,
            "commit_tracking": True,
            "health_scoring": True,
            "auto_issue_creation": True,
            "workflow_triggering": True,
            "api_rate_limit": "5000/hour" if self.api_key else "60/hour",
            "authenticated": bool(self.api_key)
        }

github = GitHubAgent()
