# ZORA MODULE HEADER

"""
Module Name: sync_utils
Generated by ZORA SYSTEM â€“ All rights reserved.
ZORA CORE Synchronization Utilities
"""

import time
import json
import logging
import asyncio
import websockets
from typing import Dict, Any, List, Optional
from datetime import datetime

class ZoraSyncLogger:
    """Advanced logging system for ZORA synchronization"""
    
    def __init__(self):
        self.logger = logging.getLogger("zora.sync")
        self.logger.setLevel(logging.INFO)
        
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - ZORA.SYNC - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
    
    def log_sync_event(self, agent_name: str, response: Dict[str, Any]):
        """Log synchronization events"""
        timestamp = datetime.utcnow().isoformat()
        log_data = {
            "timestamp": timestamp,
            "agent": agent_name,
            "status": response.get("status", "unknown"),
            "message": response.get("message", ""),
            "sync_cycle": "âˆž ZORA INFINITY LOOP"
        }
        
        self.logger.info(f"SYNC: {agent_name} - {response.get('status', 'unknown')}")
        return log_data

class ZoraWebSocketSync:
    """WebSocket synchronization for real-time agent communication"""
    
    def __init__(self):
        self.connections = set()
        self.sync_data = []
        self.server = None
    
    async def register_connection(self, websocket, path):
        """Register new WebSocket connection"""
        self.connections.add(websocket)
        try:
            await websocket.wait_closed()
        finally:
            self.connections.remove(websocket)
    
    async def broadcast_sync(self, agent_name: str, response: Dict[str, Any]):
        """Broadcast sync data to all connected clients"""
        if self.connections:
            sync_message = {
                "type": "agent_sync",
                "agent": agent_name,
                "data": response,
                "timestamp": time.time()
            }
            
            message = json.dumps(sync_message)
            disconnected = set()
            
            for websocket in self.connections:
                try:
                    await websocket.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected.add(websocket)
            
            self.connections -= disconnected
    
    async def start_server(self, host="localhost", port=8765):
        """Start WebSocket server"""
        self.server = await websockets.serve(
            self.register_connection, host, port
        )
        print(f"ðŸ”— ZORA WebSocket Sync Server started on ws://{host}:{port}")

class ZoraRepairEngine:
    """Self-repair and recovery system for ZORA agents"""
    
    def __init__(self):
        self.repair_log = []
        self.failed_agents = set()
        self.repair_attempts = {}
    
    def diagnose_agent_failure(self, agent_name: str, error: Exception) -> Dict[str, Any]:
        """Diagnose agent failure and determine repair strategy"""
        diagnosis = {
            "agent": agent_name,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "timestamp": time.time(),
            "repair_strategy": self._determine_repair_strategy(error)
        }
        
        self.failed_agents.add(agent_name)
        self.repair_log.append(diagnosis)
        
        return diagnosis
    
    def _determine_repair_strategy(self, error: Exception) -> str:
        """Determine appropriate repair strategy based on error type"""
        error_type = type(error).__name__
        
        if "API" in str(error) or "key" in str(error).lower():
            return "api_key_refresh"
        elif "connection" in str(error).lower():
            return "connection_retry"
        elif "timeout" in str(error).lower():
            return "timeout_adjustment"
        else:
            return "module_restart"
    
    async def attempt_repair(self, agent_name: str, strategy: str) -> bool:
        """Attempt to repair failed agent"""
        attempt_count = self.repair_attempts.get(agent_name, 0) + 1
        self.repair_attempts[agent_name] = attempt_count
        
        if attempt_count > 3:
            print(f"âš ï¸ Agent {agent_name} exceeded max repair attempts")
            return False
        
        print(f"ðŸ”§ Attempting repair for {agent_name} (strategy: {strategy}, attempt: {attempt_count})")
        
        await asyncio.sleep(1)
        
        if agent_name in self.failed_agents:
            self.failed_agents.remove(agent_name)
        
        print(f"âœ… Agent {agent_name} repair completed")
        return True

sync_logger = ZoraSyncLogger()
websocket_sync = ZoraWebSocketSync()
repair_engine = ZoraRepairEngine()

def sync_all(agents: List[Any]) -> Dict[str, Any]:
    """Synchronize all agents in the ZORA system"""
    sync_results = {
        "timestamp": time.time(),
        "total_agents": len(agents),
        "successful_syncs": 0,
        "failed_syncs": 0,
        "agent_results": {}
    }
    
    for agent in agents:
        try:
            response = agent.ping("âˆž ZORA SYNC CYCLE")
            sync_results["agent_results"][agent.name] = response
            sync_results["successful_syncs"] += 1
            
            log(agent.name, response)
            
            asyncio.create_task(websocket_sync.broadcast_sync(agent.name, response))
            
        except Exception as e:
            error_response = {
                "agent": agent.name,
                "status": "error",
                "error": str(e),
                "timestamp": time.time()
            }
            sync_results["agent_results"][agent.name] = error_response
            sync_results["failed_syncs"] += 1
            
            repair(agent.name, e)
    
    return sync_results

def log(agent_name: str, response: Dict[str, Any]) -> Dict[str, Any]:
    """Log agent synchronization events"""
    return sync_logger.log_sync_event(agent_name, response)

async def websocket_sync_async(agent_name: str, response: Dict[str, Any]):
    """Async WebSocket synchronization"""
    await websocket_sync.broadcast_sync(agent_name, response)

def websocket_sync(agent_name: str, response: Dict[str, Any]):
    """WebSocket synchronization wrapper"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            asyncio.create_task(websocket_sync_async(agent_name, response))
        else:
            loop.run_until_complete(websocket_sync_async(agent_name, response))
    except Exception as e:
        print(f"WebSocket sync error for {agent_name}: {e}")

def repair(agent_name: str, error: Exception) -> bool:
    """Repair failed agent"""
    diagnosis = repair_engine.diagnose_agent_failure(agent_name, error)
    
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            asyncio.create_task(repair_engine.attempt_repair(agent_name, diagnosis["repair_strategy"]))
            return True
        else:
            return loop.run_until_complete(repair_engine.attempt_repair(agent_name, diagnosis["repair_strategy"]))
    except Exception as repair_error:
        print(f"Repair failed for {agent_name}: {repair_error}")
        return False

async def start_websocket_server():
    """Start the WebSocket server for real-time sync"""
    await websocket_sync.start_server()

def get_sync_status() -> Dict[str, Any]:
    """Get current synchronization status"""
    return {
        "active_connections": len(websocket_sync.connections),
        "failed_agents": list(repair_engine.failed_agents),
        "repair_attempts": repair_engine.repair_attempts,
        "last_sync": time.time()
    }
