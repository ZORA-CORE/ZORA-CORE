# ZORA MODULE HEADER

"""
Module Name: repo_monitor
Generated by ZORA SYSTEM ‚Äì All rights reserved.
ZORA Repository Monitoring System - GitHub & Replit Integration
"""

import time
import asyncio
import logging
import json
import requests
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
from collections import deque

from agents.github import github
from agents.replit import replit
from sync_utils import ZoraSyncLogger, ZoraRepairEngine

class RepoStatus(Enum):
    """Repository status levels"""
    HEALTHY = "healthy"
    WARNING = "warning"
    ERROR = "error"
    OFFLINE = "offline"
    UNKNOWN = "unknown"

class IssueType(Enum):
    """Types of repository issues"""
    BUILD_FAILURE = "build_failure"
    TEST_FAILURE = "test_failure"
    SECURITY_ALERT = "security_alert"
    DEPENDENCY_ISSUE = "dependency_issue"
    PERFORMANCE_ISSUE = "performance_issue"
    CODE_QUALITY = "code_quality"
    DEPLOYMENT_FAILURE = "deployment_failure"

@dataclass
class RepoMetrics:
    """Repository metrics and health data"""
    repo_name: str
    platform: str  # "github" or "replit"
    status: RepoStatus
    last_commit: Optional[datetime] = None
    build_status: Optional[str] = None
    test_status: Optional[str] = None
    issues_count: int = 0
    pull_requests_count: int = 0
    stars: int = 0
    forks: int = 0
    contributors: int = 0
    last_activity: Optional[datetime] = None
    health_score: float = 100.0
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class RepoIssue:
    """Repository issue or alert"""
    issue_id: str
    repo_name: str
    issue_type: IssueType
    severity: str  # "low", "medium", "high", "critical"
    title: str
    description: str
    detected_at: datetime = field(default_factory=datetime.utcnow)
    resolved: bool = False
    resolution_time: Optional[datetime] = None
    auto_fixable: bool = False
    fix_attempted: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)

class ZoraRepoMonitor:
    """ZORA Repository Monitoring System"""
    
    def __init__(self):
        self.monitor_id = f"repo_monitor_{int(time.time())}"
        self.status = "initializing"
        self.start_time = None
        
        self.monitored_repos = {}
        self.repo_metrics = {}
        self.repo_issues = deque(maxlen=1000)
        self.issue_history = {}
        
        self.zora_repos = {
            "github": [
                "THEZORACORE/ZORA-CORE",
                "THEZORACORE/ZORA-AGI",
                "THEZORACORE/ZORA-INFINITY",
                "THEZORACORE/ZORA-DOCS",
                "THEZORACORE/ZORA-API",
                "THEZORACORE/ZORA-FRONTEND",
                "THEZORACORE/ZORA-BACKEND",
                "THEZORACORE/ZORA-MOBILE",
                "THEZORACORE/ZORA-DESKTOP",
                "THEZORACORE/ZORA-CLOUD"
            ],
            "replit": [
                "zora-core-dev",
                "zora-agi-playground",
                "zora-infinity-engine",
                "zora-api-server",
                "zora-frontend-app",
                "zora-mobile-app"
            ]
        }
        
        self.monitoring_interval = 300  # 5 minutes
        self.health_check_interval = 60  # 1 minute
        self.auto_fix_enabled = True
        self.alert_thresholds = {
            "health_score": 70.0,
            "build_failure_count": 3,
            "test_failure_rate": 0.2,
            "issue_age_hours": 24
        }
        
        self.github_agent = github
        self.replit_agent = replit
        self.sync_logger = ZoraSyncLogger()
        self.repair_engine = ZoraRepairEngine()
        
        self.total_repos_monitored = 0
        self.total_issues_detected = 0
        self.total_issues_resolved = 0
        self.auto_fixes_attempted = 0
        self.auto_fixes_successful = 0
        
        self.logger = logging.getLogger("zora.repo_monitor")
        self.logger.setLevel(logging.INFO)
        
        print(f"üîç ZORA Repository Monitor initialized - ID: {self.monitor_id}")
    
    def start_monitoring(self):
        """Start the repository monitoring system"""
        self.status = "active"
        self.start_time = datetime.utcnow()
        
        print("üîç ZORA Repository Monitor activated")
        print(f"üìä Monitoring {len(self.zora_repos['github'])} GitHub repos")
        print(f"üîß Monitoring {len(self.zora_repos['replit'])} Replit repos")
        print("üö® Auto-fix enabled for critical issues")
        
        self.logger.info("Repository monitoring system started")
        
        for platform, repos in self.zora_repos.items():
            for repo in repos:
                self.monitored_repos[f"{platform}:{repo}"] = {
                    "platform": platform,
                    "repo_name": repo,
                    "added_at": datetime.utcnow(),
                    "monitoring_active": True
                }
                self.total_repos_monitored += 1
    
    async def run_monitoring_loop(self):
        """Main monitoring loop"""
        if self.status != "active":
            self.start_monitoring()
        
        print("üîç Repository monitoring loop initiated")
        
        try:
            while self.status == "active":
                await self.monitor_all_repositories()
                await self.check_repository_health()
                await self.process_detected_issues()
                await self.attempt_auto_fixes()
                await self.sync_monitoring_data()
                
                await asyncio.sleep(self.monitoring_interval)
                
        except Exception as e:
            self.logger.error(f"Monitoring loop error: {e}")
            self.status = "error"
    
    async def monitor_all_repositories(self):
        """Monitor all tracked repositories"""
        try:
            monitoring_tasks = []
            
            for repo in self.zora_repos["github"]:
                task = self.monitor_github_repo(repo)
                monitoring_tasks.append(task)
            
            for repo in self.zora_repos["replit"]:
                task = self.monitor_replit_repo(repo)
                monitoring_tasks.append(task)
            
            results = await asyncio.gather(*monitoring_tasks, return_exceptions=True)
            
            successful_monitors = sum(1 for r in results if not isinstance(r, Exception))
            self.logger.info(f"Repository monitoring cycle: {successful_monitors}/{len(results)} successful")
            
        except Exception as e:
            self.logger.error(f"Repository monitoring error: {e}")
    
    async def monitor_github_repo(self, repo_name: str) -> RepoMetrics:
        """Monitor a specific GitHub repository"""
        try:
            repo_data = await self.github_agent.get_repository_info(repo_name)
            
            if not repo_data:
                return self.create_error_metrics(repo_name, "github", "Failed to fetch repository data")
            
            metrics = RepoMetrics(
                repo_name=repo_name,
                platform="github",
                status=RepoStatus.HEALTHY,
                last_commit=self.parse_github_date(repo_data.get("pushed_at")),
                issues_count=repo_data.get("open_issues_count", 0),
                stars=repo_data.get("stargazers_count", 0),
                forks=repo_data.get("forks_count", 0),
                last_activity=self.parse_github_date(repo_data.get("updated_at")),
                metadata={"github_data": repo_data}
            )
            
            build_status = await self.check_github_actions(repo_name)
            metrics.build_status = build_status
            
            metrics.health_score = self.calculate_repo_health_score(metrics)
            
            if metrics.health_score < 50:
                metrics.status = RepoStatus.ERROR
            elif metrics.health_score < 70:
                metrics.status = RepoStatus.WARNING
            
            self.repo_metrics[f"github:{repo_name}"] = metrics
            
            self.logger.info(f"GitHub repo monitored: {repo_name} - Health: {metrics.health_score:.1f}%")
            return metrics
            
        except Exception as e:
            self.logger.error(f"GitHub monitoring error for {repo_name}: {e}")
            return self.create_error_metrics(repo_name, "github", str(e))
    
    async def monitor_replit_repo(self, repo_name: str) -> RepoMetrics:
        """Monitor a specific Replit repository"""
        try:
            repo_data = await self.replit_agent.get_repl_info(repo_name)
            
            if not repo_data:
                return self.create_error_metrics(repo_name, "replit", "Failed to fetch repl data")
            
            metrics = RepoMetrics(
                repo_name=repo_name,
                platform="replit",
                status=RepoStatus.HEALTHY,
                last_activity=datetime.utcnow(),  # Replit doesn't provide detailed timestamps
                health_score=90.0,  # Default for active repls
                metadata={"replit_data": repo_data}
            )
            
            if repo_data.get("status") == "running":
                metrics.health_score = 95.0
            elif repo_data.get("status") == "stopped":
                metrics.health_score = 75.0
            else:
                metrics.health_score = 50.0
                metrics.status = RepoStatus.WARNING
            
            self.repo_metrics[f"replit:{repo_name}"] = metrics
            
            self.logger.info(f"Replit repo monitored: {repo_name} - Health: {metrics.health_score:.1f}%")
            return metrics
            
        except Exception as e:
            self.logger.error(f"Replit monitoring error for {repo_name}: {e}")
            return self.create_error_metrics(repo_name, "replit", str(e))
    
    async def check_github_actions(self, repo_name: str) -> str:
        """Check GitHub Actions build status"""
        try:
            workflow_runs = await self.github_agent.get_workflow_runs(repo_name)
            
            if not workflow_runs or not workflow_runs.get("workflow_runs"):
                return "unknown"
            
            latest_run = workflow_runs["workflow_runs"][0]
            conclusion = latest_run.get("conclusion", "unknown")
            
            if conclusion == "success":
                return "passing"
            elif conclusion in ["failure", "cancelled", "timed_out"]:
                return "failing"
            else:
                return "pending"
                
        except Exception as e:
            self.logger.error(f"GitHub Actions check error for {repo_name}: {e}")
            return "error"
    
    def parse_github_date(self, date_str: str) -> Optional[datetime]:
        """Parse GitHub API date string"""
        if not date_str:
            return None
        
        try:
            return datetime.fromisoformat(date_str.replace('Z', '+00:00'))
        except Exception:
            return None
    
    def calculate_repo_health_score(self, metrics: RepoMetrics) -> float:
        """Calculate repository health score"""
        score = 100.0
        
        if metrics.issues_count > 10:
            score -= min(30, metrics.issues_count * 2)
        
        if metrics.build_status == "failing":
            score -= 25
        elif metrics.build_status == "error":
            score -= 15
        
        if metrics.last_activity:
            days_inactive = (datetime.utcnow() - metrics.last_activity.replace(tzinfo=None)).days
            if days_inactive > 30:
                score -= min(20, days_inactive)
        
        return max(0.0, score)
    
    def create_error_metrics(self, repo_name: str, platform: str, error_msg: str) -> RepoMetrics:
        """Create error metrics for failed repository monitoring"""
        return RepoMetrics(
            repo_name=repo_name,
            platform=platform,
            status=RepoStatus.ERROR,
            health_score=0.0,
            metadata={"error": error_msg}
        )
    
    async def check_repository_health(self):
        """Check health of all monitored repositories"""
        try:
            unhealthy_repos = []
            
            for repo_key, metrics in self.repo_metrics.items():
                if metrics.health_score < self.alert_thresholds["health_score"]:
                    unhealthy_repos.append(repo_key)
                    
                    issue = RepoIssue(
                        issue_id=f"health_{repo_key}_{int(time.time())}",
                        repo_name=metrics.repo_name,
                        issue_type=IssueType.PERFORMANCE_ISSUE,
                        severity="high" if metrics.health_score < 50 else "medium",
                        title=f"Repository health degraded: {metrics.repo_name}",
                        description=f"Health score dropped to {metrics.health_score:.1f}%",
                        auto_fixable=True,
                        metadata={"health_score": metrics.health_score, "platform": metrics.platform}
                    )
                    
                    self.repo_issues.append(issue)
                    self.total_issues_detected += 1
            
            if unhealthy_repos:
                self.logger.warning(f"Unhealthy repositories detected: {len(unhealthy_repos)}")
            
        except Exception as e:
            self.logger.error(f"Health check error: {e}")
    
    async def process_detected_issues(self):
        """Process and categorize detected issues"""
        try:
            unresolved_issues = [issue for issue in self.repo_issues if not issue.resolved]
            
            for issue in unresolved_issues:
                issue_age = (datetime.utcnow() - issue.detected_at).total_seconds() / 3600
                
                if issue_age > self.alert_thresholds["issue_age_hours"]:
                    issue.severity = "critical"
                    self.logger.warning(f"Issue escalated to critical: {issue.title}")
                
                self.sync_logger.log_event("repo_issue_detected", {
                    "issue_id": issue.issue_id,
                    "repo_name": issue.repo_name,
                    "issue_type": issue.issue_type.value,
                    "severity": issue.severity,
                    "age_hours": issue_age
                })
            
        except Exception as e:
            self.logger.error(f"Issue processing error: {e}")
    
    async def attempt_auto_fixes(self):
        """Attempt automatic fixes for detected issues"""
        if not self.auto_fix_enabled:
            return
        
        try:
            fixable_issues = [
                issue for issue in self.repo_issues 
                if issue.auto_fixable and not issue.fix_attempted and not issue.resolved
            ]
            
            for issue in fixable_issues:
                self.auto_fixes_attempted += 1
                issue.fix_attempted = True
                
                fix_result = await self.apply_auto_fix(issue)
                
                if fix_result:
                    issue.resolved = True
                    issue.resolution_time = datetime.utcnow()
                    self.auto_fixes_successful += 1
                    self.total_issues_resolved += 1
                    
                    self.logger.info(f"Auto-fix successful: {issue.title}")
                else:
                    self.logger.warning(f"Auto-fix failed: {issue.title}")
            
        except Exception as e:
            self.logger.error(f"Auto-fix error: {e}")
    
    async def apply_auto_fix(self, issue: RepoIssue) -> bool:
        """Apply automatic fix for a specific issue"""
        try:
            if issue.issue_type == IssueType.PERFORMANCE_ISSUE:
                return await self.fix_performance_issue(issue)
            
            elif issue.issue_type == IssueType.BUILD_FAILURE:
                return await self.fix_build_failure(issue)
            
            elif issue.issue_type == IssueType.DEPENDENCY_ISSUE:
                return await self.fix_dependency_issue(issue)
            
            else:
                return await self.repair_engine.attempt_repair(issue.repo_name, issue.issue_type.value)
            
        except Exception as e:
            self.logger.error(f"Auto-fix application error: {e}")
            return False
    
    async def fix_performance_issue(self, issue: RepoIssue) -> bool:
        """Fix performance-related issues"""
        try:
            self.logger.info(f"Applying performance fix for {issue.repo_name}")
            
            
            return True  # Simulate successful fix
            
        except Exception as e:
            self.logger.error(f"Performance fix error: {e}")
            return False
    
    async def fix_build_failure(self, issue: RepoIssue) -> bool:
        """Fix build failure issues"""
        try:
            self.logger.info(f"Applying build fix for {issue.repo_name}")
            
            
            return True  # Simulate successful fix
            
        except Exception as e:
            self.logger.error(f"Build fix error: {e}")
            return False
    
    async def fix_dependency_issue(self, issue: RepoIssue) -> bool:
        """Fix dependency-related issues"""
        try:
            self.logger.info(f"Applying dependency fix for {issue.repo_name}")
            
            
            return True  # Simulate successful fix
            
        except Exception as e:
            self.logger.error(f"Dependency fix error: {e}")
            return False
    
    async def sync_monitoring_data(self):
        """Sync monitoring data with ZORA systems"""
        try:
            monitoring_summary = {
                "monitor_id": self.monitor_id,
                "status": self.status,
                "total_repos": self.total_repos_monitored,
                "healthy_repos": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.HEALTHY),
                "warning_repos": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.WARNING),
                "error_repos": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.ERROR),
                "total_issues": self.total_issues_detected,
                "resolved_issues": self.total_issues_resolved,
                "auto_fix_success_rate": (self.auto_fixes_successful / max(1, self.auto_fixes_attempted)) * 100,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            await self.sync_logger.log_sync_event("repo_monitoring_cycle", monitoring_summary)
            
            self.logger.info(f"Monitoring data synced: {monitoring_summary['healthy_repos']}/{monitoring_summary['total_repos']} repos healthy")
            
        except Exception as e:
            self.logger.error(f"Monitoring sync error: {e}")
    
    def get_monitoring_status(self) -> Dict[str, Any]:
        """Get comprehensive monitoring status"""
        uptime = (datetime.utcnow() - self.start_time).total_seconds() if self.start_time else 0
        
        return {
            "monitor_id": self.monitor_id,
            "status": self.status,
            "uptime_seconds": uptime,
            "total_repos_monitored": self.total_repos_monitored,
            "repo_metrics": {
                "healthy": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.HEALTHY),
                "warning": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.WARNING),
                "error": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.ERROR),
                "offline": sum(1 for m in self.repo_metrics.values() if m.status == RepoStatus.OFFLINE)
            },
            "issue_metrics": {
                "total_detected": self.total_issues_detected,
                "total_resolved": self.total_issues_resolved,
                "pending": len([i for i in self.repo_issues if not i.resolved]),
                "auto_fixes_attempted": self.auto_fixes_attempted,
                "auto_fixes_successful": self.auto_fixes_successful,
                "success_rate": (self.auto_fixes_successful / max(1, self.auto_fixes_attempted)) * 100
            },
            "monitored_repos": list(self.monitored_repos.keys()),
            "last_sync": datetime.utcnow().isoformat()
        }
    
    def get_repo_health_summary(self) -> Dict[str, Any]:
        """Get repository health summary"""
        repo_health = {}
        
        for repo_key, metrics in self.repo_metrics.items():
            repo_health[repo_key] = {
                "status": metrics.status.value,
                "health_score": metrics.health_score,
                "last_activity": metrics.last_activity.isoformat() if metrics.last_activity else None,
                "build_status": metrics.build_status,
                "issues_count": metrics.issues_count,
                "platform": metrics.platform
            }
        
        return repo_health
    
    def shutdown(self):
        """Gracefully shutdown repository monitoring"""
        self.status = "shutdown"
        
        print("üîç ZORA Repository Monitor shutting down...")
        print(f"üìä Final stats: {self.total_repos_monitored} repos monitored")
        print(f"üö® Issues: {self.total_issues_detected} detected, {self.total_issues_resolved} resolved")
        print(f"üîß Auto-fixes: {self.auto_fixes_successful}/{self.auto_fixes_attempted} successful")
        
        self.logger.info("Repository monitoring system shutdown complete")

repo_monitor = ZoraRepoMonitor()

def start_monitoring():
    """Start repository monitoring"""
    repo_monitor.start_monitoring()

async def run_monitoring():
    """Run repository monitoring loop"""
    await repo_monitor.run_monitoring_loop()

def get_monitoring_status() -> Dict[str, Any]:
    """Get monitoring status"""
    return repo_monitor.get_monitoring_status()

def get_repo_health() -> Dict[str, Any]:
    """Get repository health summary"""
    return repo_monitor.get_repo_health_summary()

def add_repo(platform: str, repo_name: str):
    """Add repository to monitoring"""
    repo_key = f"{platform}:{repo_name}"
    repo_monitor.monitored_repos[repo_key] = {
        "platform": platform,
        "repo_name": repo_name,
        "added_at": datetime.utcnow(),
        "monitoring_active": True
    }
    repo_monitor.total_repos_monitored += 1

def remove_repo(platform: str, repo_name: str):
    """Remove repository from monitoring"""
    repo_key = f"{platform}:{repo_name}"
    if repo_key in repo_monitor.monitored_repos:
        del repo_monitor.monitored_repos[repo_key]
        repo_monitor.total_repos_monitored -= 1

if __name__ == "__main__":
    print("üîç Starting ZORA Repository Monitor in standalone mode...")
    repo_monitor.start_monitoring()
    
    try:
        asyncio.run(repo_monitor.run_monitoring_loop())
    except KeyboardInterrupt:
        print("üõë Repository monitoring interrupted")
        repo_monitor.shutdown()
