#!/usr/bin/env python3
# ZORA MODULE HEADER

"""
Module Name: zora_payment_api_gateway
Generated by ZORA SYSTEM â€“ All rights reserved.
Founder: Mads Pallisgaard Petersen
Contact: mrpallis@gmail.com | +45 22822450
Address: Fjordbakken 50, Dyves Bro, 4700 NÃ¦stved
Organization: ZORA CORE

ZORA PAYMENT API GATEWAYâ„¢
Real-time API access for payment system
"""

import asyncio
import json
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import uuid
import hashlib
import hmac

from fastapi import FastAPI, HTTPException, Depends, Header, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

from zora_infinity_payment_system import zora_infinity_payment_system, PaymentMethod, Currency
from zora_ai_payment_routing_engine import zora_ai_routing_engine
from zora_payment_compliance_engine import zora_compliance_engine
from zora_payment_webhook_handler import zora_webhook_handler
from eivor_ai_family_system import eivor_family_system

class APIKeyScope(Enum):
    READ_ONLY = "read_only"
    PAYMENT_PROCESSING = "payment_processing"
    WEBHOOK_ACCESS = "webhook_access"
    ADMIN = "admin"
    FOUNDER = "founder"

@dataclass
class APIKey:
    key_id: str
    key_hash: str
    scope: APIKeyScope
    created_at: datetime
    last_used: Optional[datetime] = None
    usage_count: int = 0
    rate_limit: int = 1000
    is_active: bool = True

class PaymentRequest(BaseModel):
    amount: float = Field(..., gt=0, description="Payment amount")
    currency: str = Field(..., description="Payment currency")
    payment_method: str = Field(..., description="Payment method")
    customer_id: str = Field(..., description="Customer identifier")
    merchant_id: str = Field(default="ZORA_CORE", description="Merchant identifier")
    description: str = Field(default="ZORA Payment", description="Payment description")
    customer_location: str = Field(default="US", description="Customer location")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")

class PaymentResponse(BaseModel):
    status: str
    transaction_id: str
    message: str
    processing_time: Optional[float] = None
    routing_path: Optional[str] = None
    compliance_checks: Optional[List[str]] = None

class SystemStatusResponse(BaseModel):
    system_id: str
    status: str
    uptime: str
    supported_payment_methods: int
    supported_currencies: int
    supported_countries: int
    total_transactions: int
    success_rate: float
    launch_readiness: Dict[str, Any]

class ZoraPaymentAPIGateway:
    """Real-time API access for payment system"""
    
    def __init__(self):
        self.gateway_id = f"api_gateway_{int(time.time())}"
        self.status = "initializing"
        self.start_time = datetime.utcnow()
        
        self.api_keys = {}
        self.rate_limits = {}
        self.request_history = []
        
        self.app = FastAPI(
            title="ZORA PAYMENT API GATEWAYâ„¢",
            description="Real-time API access for ZORA INFINITY PAYMENT SYSTEMâ„¢",
            version="1.0.0-INFINITY",
            docs_url="/docs",
            redoc_url="/redoc"
        )
        
        self._setup_middleware()
        self._setup_routes()
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        print(f"ğŸŒ ZORA PAYMENT API GATEWAYâ„¢ initialized: {self.gateway_id}")
    
    def _setup_middleware(self):
        """Setup API middleware"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def _setup_routes(self):
        """Setup API routes"""
        
        @self.app.get("/", response_model=Dict[str, str])
        async def root():
            return {
                "service": "ZORA PAYMENT API GATEWAYâ„¢",
                "version": "1.0.0-INFINITY",
                "status": self.status,
                "founder": "Mads Pallisgaard Petersen",
                "launch_date": "2025-09-23T12:00:00Z"
            }
        
        @self.app.get("/health", response_model=Dict[str, Any])
        async def health_check():
            uptime = datetime.utcnow() - self.start_time
            return {
                "status": "healthy",
                "uptime_seconds": uptime.total_seconds(),
                "gateway_id": self.gateway_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        
        @self.app.get("/status", response_model=SystemStatusResponse)
        async def get_system_status(api_key: str = Depends(self._verify_api_key)):
            payment_status = zora_infinity_payment_system.get_system_status()
            analytics = await zora_infinity_payment_system.get_real_time_analytics()
            
            uptime = datetime.utcnow() - self.start_time
            
            return SystemStatusResponse(
                system_id=payment_status["system_id"],
                status=payment_status["status"],
                uptime=str(uptime),
                supported_payment_methods=payment_status["supported_payment_methods"],
                supported_currencies=payment_status["supported_currencies"],
                supported_countries=payment_status["supported_countries"],
                total_transactions=analytics["real_time_metrics"]["total_transactions"],
                success_rate=analytics["real_time_metrics"]["success_rate"],
                launch_readiness=analytics["launch_readiness"]
            )
        
        @self.app.post("/payments", response_model=PaymentResponse)
        async def process_payment(
            payment_request: PaymentRequest,
            api_key: str = Depends(self._verify_payment_api_key)
        ):
            start_time = time.time()
            
            try:
                transaction_data = {
                    "transaction_id": str(uuid.uuid4()),
                    "amount": payment_request.amount,
                    "currency": payment_request.currency,
                    "payment_method": payment_request.payment_method,
                    "customer_id": payment_request.customer_id,
                    "merchant_id": payment_request.merchant_id,
                    "description": payment_request.description,
                    "customer_location": payment_request.customer_location,
                    "metadata": payment_request.metadata
                }
                
                compliance_checks = await zora_compliance_engine.check_transaction_compliance(transaction_data)
                
                routing_path = await zora_ai_routing_engine.route_payment_intelligently(transaction_data)
                
                from zora_infinity_payment_system import process_payment
                result = await process_payment(transaction_data)
                
                processing_time = time.time() - start_time
                
                return PaymentResponse(
                    status=result["status"],
                    transaction_id=result["transaction_id"],
                    message=f"Payment {result['status']}",
                    processing_time=processing_time,
                    routing_path=routing_path.path_id if routing_path else None,
                    compliance_checks=[check.framework.value for check in compliance_checks]
                )
                
            except Exception as e:
                self.logger.error(f"Payment processing error: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/payments/{transaction_id}")
        async def get_payment_status(
            transaction_id: str,
            api_key: str = Depends(self._verify_api_key)
        ):
            if transaction_id in zora_infinity_payment_system.transactions:
                transaction = zora_infinity_payment_system.transactions[transaction_id]
                return {
                    "transaction_id": transaction.transaction_id,
                    "status": transaction.status.value,
                    "amount": transaction.amount,
                    "currency": transaction.currency.value,
                    "created_at": transaction.created_at.isoformat(),
                    "risk_level": transaction.risk_level.value
                }
            else:
                raise HTTPException(status_code=404, detail="Transaction not found")
        
        @self.app.post("/webhooks/{provider}")
        async def handle_webhook(
            provider: str,
            request: Request,
            x_signature: Optional[str] = Header(None),
            stripe_signature: Optional[str] = Header(None)
        ):
            payload = await request.json()
            signature = x_signature or stripe_signature or ""
            headers = dict(request.headers)
            
            result = await zora_webhook_handler.process_webhook(provider, payload, signature, headers)
            
            return result
        
        @self.app.get("/analytics/real-time")
        async def get_real_time_analytics(api_key: str = Depends(self._verify_api_key)):
            analytics = await zora_infinity_payment_system.get_real_time_analytics()
            return analytics
        
        @self.app.get("/routing/status")
        async def get_routing_status(api_key: str = Depends(self._verify_api_key)):
            return zora_ai_routing_engine.get_routing_status()
        
        @self.app.get("/compliance/status")
        async def get_compliance_status(api_key: str = Depends(self._verify_api_key)):
            return zora_compliance_engine.get_compliance_status()
        
        @self.app.get("/webhooks/status")
        async def get_webhook_status(api_key: str = Depends(self._verify_api_key)):
            return zora_webhook_handler.get_webhook_status()
        
        @self.app.post("/api-keys")
        async def create_api_key(
            scope: APIKeyScope,
            founder_key: str = Depends(self._verify_founder_access)
        ):
            api_key = self._generate_api_key(scope)
            return {
                "key_id": api_key.key_id,
                "api_key": f"zora_{api_key.key_id}_{api_key.key_hash[:16]}",
                "scope": api_key.scope.value,
                "created_at": api_key.created_at.isoformat()
            }
        
        @self.app.get("/api-keys")
        async def list_api_keys(founder_key: str = Depends(self._verify_founder_access)):
            return [
                {
                    "key_id": key.key_id,
                    "scope": key.scope.value,
                    "created_at": key.created_at.isoformat(),
                    "last_used": key.last_used.isoformat() if key.last_used else None,
                    "usage_count": key.usage_count,
                    "is_active": key.is_active
                }
                for key in self.api_keys.values()
            ]
    
    async def initialize_api_gateway(self):
        """Initialize API gateway with default configurations"""
        print("ğŸŒ Initializing API gateway...")
        
        self.status = "initializing"
        
        await self._initialize_default_api_keys()
        await self._initialize_rate_limiting()
        await self._initialize_security_protocols()
        
        self.status = "active"
        print("âœ… API gateway fully operational")
        
        return True
    
    async def _initialize_default_api_keys(self):
        """Initialize default API keys"""
        print("ğŸ”‘ Initializing default API keys...")
        
        founder_key = self._generate_api_key(APIKeyScope.FOUNDER)
        admin_key = self._generate_api_key(APIKeyScope.ADMIN)
        read_key = self._generate_api_key(APIKeyScope.READ_ONLY)
        
        print(f"âœ… Generated {len(self.api_keys)} default API keys")
        print(f"ğŸ”‘ Founder Key: zora_{founder_key.key_id}_{founder_key.key_hash[:16]}")
        print(f"ğŸ”‘ Admin Key: zora_{admin_key.key_id}_{admin_key.key_hash[:16]}")
        print(f"ğŸ”‘ Read Key: zora_{read_key.key_id}_{read_key.key_hash[:16]}")
    
    async def _initialize_rate_limiting(self):
        """Initialize rate limiting configurations"""
        print("â±ï¸ Initializing rate limiting...")
        
        rate_limits = {
            APIKeyScope.READ_ONLY: 100,
            APIKeyScope.PAYMENT_PROCESSING: 1000,
            APIKeyScope.WEBHOOK_ACCESS: 5000,
            APIKeyScope.ADMIN: 10000,
            APIKeyScope.FOUNDER: 100000
        }
        
        self.rate_limits = rate_limits
        print("âœ… Rate limiting configured")
    
    async def _initialize_security_protocols(self):
        """Initialize API security protocols"""
        print("ğŸ›¡ï¸ Initializing API security...")
        
        print("âœ… API security protocols activated")
    
    def _generate_api_key(self, scope: APIKeyScope) -> APIKey:
        """Generate new API key"""
        key_id = str(uuid.uuid4())[:8]
        key_data = f"{key_id}_{scope.value}_{int(time.time())}"
        key_hash = hashlib.sha256(key_data.encode()).hexdigest()
        
        api_key = APIKey(
            key_id=key_id,
            key_hash=key_hash,
            scope=scope,
            created_at=datetime.utcnow(),
            rate_limit=self.rate_limits.get(scope, 1000)
        )
        
        self.api_keys[key_id] = api_key
        return api_key
    
    async def _verify_api_key(self, authorization: str = Header(...)) -> str:
        """Verify API key for general access"""
        if not authorization.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Invalid authorization header")
        
        api_key = authorization.replace("Bearer ", "")
        
        if not api_key.startswith("zora_"):
            raise HTTPException(status_code=401, detail="Invalid API key format")
        
        key_parts = api_key.split("_")
        if len(key_parts) < 3:
            raise HTTPException(status_code=401, detail="Invalid API key format")
        
        key_id = key_parts[1]
        
        if key_id not in self.api_keys:
            raise HTTPException(status_code=401, detail="Invalid API key")
        
        api_key_obj = self.api_keys[key_id]
        
        if not api_key_obj.is_active:
            raise HTTPException(status_code=401, detail="API key is inactive")
        
        api_key_obj.last_used = datetime.utcnow()
        api_key_obj.usage_count += 1
        
        return api_key
    
    async def _verify_payment_api_key(self, authorization: str = Header(...)) -> str:
        """Verify API key for payment processing"""
        api_key = await self._verify_api_key(authorization)
        
        key_parts = api_key.split("_")
        key_id = key_parts[1]
        api_key_obj = self.api_keys[key_id]
        
        if api_key_obj.scope not in [APIKeyScope.PAYMENT_PROCESSING, APIKeyScope.ADMIN, APIKeyScope.FOUNDER]:
            raise HTTPException(status_code=403, detail="Insufficient permissions for payment processing")
        
        return api_key
    
    async def _verify_founder_access(self, authorization: str = Header(...)) -> str:
        """Verify founder-level API access"""
        api_key = await self._verify_api_key(authorization)
        
        key_parts = api_key.split("_")
        key_id = key_parts[1]
        api_key_obj = self.api_keys[key_id]
        
        if api_key_obj.scope != APIKeyScope.FOUNDER:
            raise HTTPException(status_code=403, detail="Founder access required")
        
        return api_key
    
    def get_gateway_status(self) -> Dict[str, Any]:
        """Get comprehensive API gateway status"""
        uptime = datetime.utcnow() - self.start_time
        
        return {
            "gateway_id": self.gateway_id,
            "status": self.status,
            "uptime_seconds": uptime.total_seconds(),
            "total_api_keys": len(self.api_keys),
            "active_api_keys": len([k for k in self.api_keys.values() if k.is_active]),
            "total_requests": len(self.request_history),
            "supported_endpoints": [
                "/", "/health", "/status", "/payments", "/webhooks/{provider}",
                "/analytics/real-time", "/routing/status", "/compliance/status",
                "/webhooks/status", "/api-keys"
            ]
        }

zora_api_gateway = ZoraPaymentAPIGateway()

async def initialize_api_gateway():
    """Initialize API gateway"""
    return await zora_api_gateway.initialize_api_gateway()

def get_fastapi_app():
    """Get FastAPI application instance"""
    return zora_api_gateway.app

def get_gateway_status():
    """Get API gateway status"""
    return zora_api_gateway.get_gateway_status()

async def main():
    """Main demonstration of API gateway capabilities"""
    print("ğŸŒ ZORA PAYMENT API GATEWAYâ„¢ - Real-time API Access")
    print("=" * 70)
    
    await initialize_api_gateway()
    
    status = get_gateway_status()
    print(f"ğŸš€ Gateway Status: {status['status']}")
    print(f"ğŸ”‘ API Keys: {status['total_api_keys']}")
    print(f"ğŸ“¡ Endpoints: {len(status['supported_endpoints'])}")
    print(f"â±ï¸ Uptime: {status['uptime_seconds']:.1f}s")
    
    print("\nğŸ“‹ Available Endpoints:")
    for endpoint in status['supported_endpoints']:
        print(f"  â€¢ {endpoint}")
    
    print("\nâœ… API gateway ready for global launch!")
    print("ğŸŒ Access documentation at: /docs")
    print("ğŸ“Š Real-time monitoring at: /status")

if __name__ == "__main__":
    asyncio.run(main())
